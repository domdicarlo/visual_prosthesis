using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net.Sockets;


// Seizure Filter EEG Program 
// Started by Dominic DiCarlo September 2018

// This program requires communication with OpenViBE acquisition software
// as well as designer software. That software can be obtained from
// Brain Products, and is found on the flash drive Towle lab
// received from them.

// What this program does:
//
// This program reads in data from a TCP server generated by OpenViBE Designer 
// It takes in the data given at 512 Hz signal delivered in 4 sample chunks 
// (or a 128 Hz signal delivering 4 samples at a time) and calculates
// the RMS to (theoretically) predict when a seizure might be coming on.
// if the RMS approaches certain upper or lower bounds, the graphical interface
// of the program will change the color of a bar to signify this, from green (safe)
// to yellow (caution), to red (danger). Right now, the upper and lower bounds of
// these ranges has been arbitrarily decided. To use this program for the
// visual prosthesis, these values will either have to be pre-determined
// or determined after experimentation has begun. We must decide whether to
// err on the side of safety or risk. 

// How to Run the program:
// 1) Connect the V-Amplifier to the computer and install any drivers
//    you may be prompted to. The Brain Products usb will also install some drivers
//    to your PC; these are needed for the V-Amp (supposedly)
//
// 2) Open OpenViBE Acquisition Server. Select V-Amp/Fast Amp from the Driver drop
//    down menu. Adjust drift tolerance to 2.00 ms or lower from the Preferences button.
//    Set "Sample count per sent block" to 4.
//
// 3) Open OpenViBE Designer. If this is your first time, select
//    an "Acquisition Client" box from the folder "Acquisition and network IO".
//    connect this to a "Temporal filter" box from '"Signal Processing"->"Temporal Filtering"'.
//    Connect the "Temporal filter" box to a "Signal display" box and a "Matrix sender" box.
//
//    IMPORTANT: Assure the "Matrix sender" box has TCP port "1234". You can check this by
//    double clicking it, and seeing the TCP port. 
//
//    EQUALLY IMPORANT: Assure the "Acquisition client" box has the same acquisition server
//    port as the Connection port number on OpenViBE Acquisition Server. You can check the box
//    by double clicking it, and the actual Acquisition Server right on the front of the program
//
//    All the program really needs from designer is the "Matrix Sender", as this is what it reads.
//    Feel free to adjust the Temporal Filter to your exact frequency needs,
//    as well as adjust the signal display parameters for your needs. 
//
//    You can save your settings in OpenViBE Designer as a config file. Simply
//    click Save As at the top or Save. 
//
// 4) Hit Start at the top of Visual Studio, or run this program in the packaged way
//    you have decided. Then, hit the play arrow on top of OpenViBE designer. 
//    Voila! The program should be running. If not, run through these steps again
//    and ensure you have done everything right.


// Some things to consider integrating:
//
// 1) It would be nice to be able to change the upper and lower bounds of the RMS
//    safety window from the GUI. This change could be easily made
//
// 2) Adding more channels and the ability to manage multiple samples from the stream
//    at once.
//    - There is room in the logic to do this, and it would just look like more
//      of the same code. We would need to decide how many channels we want to 
//      look at in the first place.
//
// 3) Adding in EEG visualization
//      - OpenViBE supplies this in the mean time, but creating our own EEG viewer
//        would be optimal as we can modify it to suit our needs.
//
// 4) Some visualization of the RMS over time
//      - This would be very useful, as right now we only get monitoring of the present
//        state of the RMS, and we might want to look at the trends it is taking.
//
// 5) Writing the CSV of values from the experiment in a path that will work for
//    all systems
//      - Right now, the CSV path has to be edited in the code
//        so that it works on other systems. What would be more ideal
//        would be the user selecting a path before the program begins. 
//        This would be easy to program. 

// The logic of everything is simplified right now to only work with one
// channel and one sample at a time. This is then a skeleton for more work
// depending on how much data you want to use. 

namespace WindowsFormsApp4
{
    public partial class Form1 : Form
    {
        // these are the publically defined range values
        // for the RMS. The Red range is for absolute danger
        // while the Yellow (ylw) range is for caution.
        public double redRangeRmsUp = 1.4;
        public double redRangeRmsLow = 0.6;
        public double ylwRangeRmsUp = 1.2;
        public double ylwRangeRmsLow = 0.8;


        private Thread logic_thread;
        private Thread form_thread;
        public Form1()
        {
            InitializeComponent();
            this.Load += Form1_Load;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            logic_thread = new Thread(drawRMS);
            logic_thread.Start();
        }
        private void Form1_newForm(object sender, EventArgs e)
        {
            form_thread = new Thread(form2);
            form_thread.Start();
        }
     
        public void form2()
        {

        }
        public void drawRMS()
        {
           
            
            try
            {

                TcpClient client = new TcpClient();


                // ip addess should be local host, TCP port is as specified in
                // Open Vibe program.
                client.Connect("127.0.0.1", 1234);
                // this log.invoke is the method used to edit the text
                // boxes in the windows form
                log.Invoke(new Action(() =>
                {
                    log.Text = "Connected!";
                }));
       
                // Buffer for reading data
                // Data comes in as ASCII string of comma separated values
                Byte[] bytes = new Byte[16384];

                // this array stores the values in a 500 ms interval to perform root 
                // mean square analysis
                // 64 values represents 500 ms. Because we have a 512 Hz signal from
                // the V-Amp, and we receive a chunk every 4 samples --> 512 / 4 = 128. 
                // 128 samples per second --> 64 samples per 1/2 second, or 500 ms.
                uint maxSamplesStored = 64;

                // we use 4 arrays so we can calculate every 16 values, or in a 125 ms interval
                // In other words, every 125 ms we need to be able to pull up
                // the last 500 ms worth of values. So every 16 values we need to pull up 
                // the last 64 values. So each of these arrays is separated from the next by 
                // 16 values.
                Double[] storedValues1 = new Double[maxSamplesStored];
                Double[] storedValues2 = new Double[maxSamplesStored];
                Double[] storedValues3 = new Double[maxSamplesStored];
                Double[] storedValues4 = new Double[maxSamplesStored];

                // this array will
                // be used in the calculation step (changes every 16 values)
                Double[] calcValues = new Double[maxSamplesStored];

                // initiating the double for the channel sample values
                // can initialize more channels and samples
                double channel1Sample1 = 0;
                // double channel1Sample2 = 0; // EX: more channels/samples

                // Enter the listening loop.
                while (true)
                {
                    int i;
                    int count = 0;
                    // this is how many samples are read before the program is auto shut down.
                    // 3840 is roughly 30 seconds
                    Stream stream = client.GetStream();

                    // build csv file
                    // need to customize where to save the text. possibly with user input
                    string csvFilePath = @"C:\Users\Towle\Desktop\testfile.csv";
                    File.WriteAllText(csvFilePath, "");

                    // stream so long as there is something to stream, or until the limit 
                    // number of samples have been collected.
                    while ((i = stream.Read(bytes, 0, bytes.Length)) != 0)
                        {   
                            string data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
                            log.Invoke(new Action(() =>
                            {
                                //log.Text = String.Format("Channel 1, Sample 1: {0} 
                                // Channel 2, Sample 1: {0}", channel1Sample1); // , channel2Sample1);
                                log.Text = data; // , channel2Sample1);

                            }));
                            // the format of this string array is all the channels for sample 1, 
                            // all the channels for sample 2, ... all
                            // the channels for sample N, for a stream with N channels. 
                            // we are taking the one, long data string and separating it into 
                            // its components
                            string[] niceData = data.Split(',');
                            double.TryParse(niceData[0], out channel1Sample1);

                            // EX: More channels / samples
                            // double.TryParse(niceData[0], out channel1Sample2);
                            // double channel2Sample1 = double.Parse(niceData[1]);


                            // EX: displaying channel 1 sample 1 to the box everytime 
                            // log.Invoke(new Action(() =>
                            // {
                            //     log.Text = String.Format("Channel 1, Sample 1: {0}", 
                                        // channel1Sample1); // , channel2Sample1);
                            //
                            // }));
                            // 

                            // calculate current array slot for the four different arrays
                            // each array is 16 slots ahead of the next in terms
                            // of the data stream. this is why 16 is subtracted from the first
                            // to make the second, and another 16 from the second for the third, etc.
                            int currentSlotArray1 = count % 64;
                            int currentSlotArray2 = (count - 16) % 64;
                            int currentSlotArray3 = (count - 32) % 64;
                            int currentSlotArray4 = (count - 48) % 64;

                            // we don't want to start calculating until we have at least 64 values,
                            // so we don't negatively index any arrays.
                            if (count > 63)
                            {
                                storedValues1[currentSlotArray1] = channel1Sample1;
                                storedValues2[currentSlotArray2] = channel1Sample1;
                                storedValues3[currentSlotArray3] = channel1Sample1;
                                storedValues4[currentSlotArray4] = channel1Sample1;
                            }
                            // proceed to calculation step
                            // perform a calculation every 16th iteration 
                            if (count > 63 && ((currentSlotArray1 + 1) % 16 == 0)) 
                            
                            {
                                switch (currentSlotArray1 + 1)
                                {
                                    case 16:
                                        calcValues = storedValues1;
                                        break;
                                    case 32:
                                        calcValues = storedValues2;
                                        break;
                                    case 48:
                                        calcValues = storedValues3;
                                        break;
                                    case 64:
                                        calcValues = storedValues4;
                                        break;
                                }
                                                                 
                                // run a calculation
                                double rms1 = 0;
                                // taking the sum of normalized squares
                                foreach (double v in calcValues)
                                {
                                    rms1 += (v * v);
                                }
                                // taking the square root of that sum
                                rms1 = Math.Sqrt(rms1 / calcValues.Length);
                                // display result
                                rms_val.Invoke(new Action(() =>
                                {
                                    rms_val.Text = String.Format("{0}", rms1);

                                }));
                                // color step
                                if (rms1 < redRangeRmsLow | rms1 > redRangeRmsUp) // red - danger
                                {
                                    panel1.BackColor = Color.FromArgb(255, 0, 0);
                                }
                                else if (rms1 < ylwRangeRmsLow | rms1 > ylwRangeRmsUp) // yellow - caution
                                {
                                    panel1.BackColor = Color.FromArgb(255, 255, 0);
                                }
                                else // green - safe
                                {
                                    panel1.BackColor = Color.FromArgb(0, 255, 0);
                                }
                                
                            }
                              
                      
                                // format the lines for the csv file
                                string nextLine = string.Format("{0}\n", channel1Sample1);

                                // append lines to csv file
                                File.AppendAllText(csvFilePath, nextLine);
                                count++;
                        }
                    // this code should technically never be reached    
                    client.Close();
                }
            }

            // this is reached if we have trouble connecting with the client. 
            // it calls on the function again in case the connection error
            // is just a small hitch to prevent having to restart the program.
            catch (Exception e)
            {
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                drawRMS();
            }
        }
    }
}
